/* -*- c -*- */

/*
 * 
 * The code is based on the quickselect from
 * Nicolas Devillard - 1998 public domain
 * http://ndevilla.free.fr/median/median/
 *
 * Quick select is usually the fastest, but the worst case scenario can
 * be quadratic complexcity.
 */


#define NPY_NO_DEPRECATED_API NPY_API_VERSION

#include "npy_sort.h"
#include "npysort_common.h"
#include "numpy/npy_math.h"
#include <stdlib.h>

#define NOT_USED NPY_UNUSED(unused)


/*
 *****************************************************************************
 **                            NUMERIC SORTS                                **
 *****************************************************************************
 */


/**begin repeat
 *
 * #TYPE = BOOL, BYTE, UBYTE, SHORT, USHORT, INT, UINT, LONG, ULONG,
 *         LONGLONG, ULONGLONG, HALF, FLOAT, DOUBLE, LONGDOUBLE,
 *         CFLOAT, CDOUBLE, CLONGDOUBLE#
 * #suff = bool, byte, ubyte, short, ushort, int, uint, long, ulong,
 *         longlong, ulonglong, half, float, double, longdouble,
 *         cfloat, cdouble, clongdouble#
 * #type = npy_bool, npy_byte, npy_ubyte, npy_short, npy_ushort, npy_int,
 *         npy_uint, npy_long, npy_ulong, npy_longlong, npy_ulonglong,
 *         npy_ushort, npy_float, npy_double, npy_longdouble, npy_cfloat,
 *         npy_cdouble, npy_clongdouble#
 */

int
introselect_@suff@(@type@ *v, npy_intp num, npy_intp kth,
                   void *NOT_USED);
int
aintroselect_@suff@(@type@ *v, npy_intp * tosort, npy_intp num,
                    npy_intp kth, void *NOT_USED);

static npy_intp
amedian_of_median5_@suff@(@type@ *v, npy_intp* tosort, const npy_intp num);

static npy_intp
median_of_median5_@suff@(@type@ *v, const npy_intp num);

/**begin repeat1
 * #name = , a#
 * #idx = , tosort#
 * #arg = 0, 1#
 */
#if @arg@
#define IDX(x) tosort[x]
#define SORTEE(x) tosort[x]
#define SWAP INTP_SWAP
#define MEDIAN3_SWAP(v, tosort, low, mid, high) \
    amedian3_swap_@suff@(v, tosort, low, mid, high)
#define MEDIAN5(v, tosort, subleft) \
        amedian5_@suff@(v, tosort + subleft)
#define UNGUARDED_PARTITION(v, tosort, pivot, ll, hh) \
        aunguarded_partition_@suff@(v, tosort, pivot, ll, hh)
#define INTROSELECT(v, tosort, num, kth) \
        aintroselect_@suff@(v, tosort, nmed, nmed / 2, NULL)
#else
#define IDX(x) (x)
#define SORTEE(x) v[x]
#define SWAP @TYPE@_SWAP
#define MEDIAN3_SWAP(v, tosort, low, mid, high) \
    median3_swap_@suff@(v, low, mid, high)
#define MEDIAN5(v, tosort, subleft) \
        median5_@suff@(v + subleft)
#define UNGUARDED_PARTITION(v, tosort, pivot, ll, hh) \
        unguarded_partition_@suff@(v, pivot, ll, hh)
#define INTROSELECT(v, tosort, num, kth) \
        introselect_@suff@(v, nmed, nmed / 2, NULL)
#endif


/*
 * median of 3 pivot strategy
 * gets min and median and moves median to low and min to low + 1
 * for efficient partitioning
 */
static NPY_INLINE void
@name@median3_swap_@suff@(@type@ * v,
#if @arg@
                          npy_intp * tosort,
#endif
                          npy_intp low, npy_intp mid, npy_intp high)
{
    if (@TYPE@_LT(v[IDX(high)], v[IDX(mid)]))
        SWAP(SORTEE(high), SORTEE(mid));
    if (@TYPE@_LT(v[IDX(high)], v[IDX(low)]))
        SWAP(SORTEE(high), SORTEE(low));
    /* move pivot to low */
    if (@TYPE@_LT(v[IDX(low)], v[IDX(mid)]))
        SWAP(SORTEE(low), SORTEE(mid));
    /* move 3-lowest element to low + 1 */
    SWAP(SORTEE(mid), SORTEE(low + 1));
}


/* select index of median of five elements */
static npy_intp @name@median5_@suff@(
#if @arg@
                                    const @type@ * v, npy_intp * tosort
#else
                                    @type@ * v
#endif
                                    )
{
    /* could be optimized as we don't need to swap */
    if (@TYPE@_LT(v[IDX(1)], v[IDX(0)])) {
        SWAP(SORTEE(1), SORTEE(0));
    }
    if (@TYPE@_LT(v[IDX(4)], v[IDX(3)])) {
        SWAP(SORTEE(4), SORTEE(3));
    }
    if (@TYPE@_LT(v[IDX(3)], v[IDX(0)])) {
        SWAP(SORTEE(3), SORTEE(0));
    }
    if (@TYPE@_LT(v[IDX(4)], v[IDX(1)])) {
        SWAP(SORTEE(4), SORTEE(1));
    }
    if (@TYPE@_LT(v[IDX(2)], v[IDX(1)])) {
        SWAP(SORTEE(2), SORTEE(1));
    }
    if (@TYPE@_LT(v[IDX(3)], v[IDX(2)])) {
        if (@TYPE@_LT(v[IDX(3)], v[IDX(1)])) {
            return 1;
        }
        else {
            return 3;
        }
    }
    else {
        if (@TYPE@_LT(v[IDX(2)], v[IDX(1)])) {
            return 1;
        }
        else {
            return 2;
        }
    }
}


/*
 * partition and return the index were the pivot belongs
 * pivot can't be smallest or largest element
 */
static NPY_INLINE void
@name@unguarded_partition_@suff@(@type@ * v,
#if @arg@
                                 npy_intp * tosort,
#endif
                                 const @type@ pivot,
                                 npy_intp * ll, npy_intp * hh)
{
    for (;;) {
        do (*ll)++; while (@TYPE@_LT(v[IDX(*ll)], pivot));
        do (*hh)--; while (@TYPE@_LT(pivot, v[IDX(*hh)]));

        if (*hh < *ll)
            break;

        SWAP(SORTEE(*ll), SORTEE(*hh));
    }
}


static npy_intp
@name@median_of_median5_@suff@(@type@ *v,
#if @arg@
                               npy_intp* tosort,
#endif
                               const npy_intp num)
{
    npy_intp i, subleft;
    npy_intp right = num - 1;
    npy_intp nmed = (right + 1) / 5;
    for (i = 0, subleft = 0; i < nmed; i++, subleft += 5) {
        npy_intp m = MEDIAN5(v, tosort, subleft);
        SWAP(SORTEE(subleft + m), SORTEE(i));
    }

    if (nmed > 2)
        INTROSELECT(v, tosort, nmed, nmed / 2);
    return nmed / 2;
}


int
@name@introselect_@suff@(@type@ *v,
#if @arg@
                         npy_intp* tosort,
#endif
                         npy_intp num, npy_intp kth, void *NOT_USED)
{
    npy_intp low  = 0;
    npy_intp high = num - 1;
    npy_intp depth_limit = npy_log2(num) * 2;

    /* guarantee three elements */
    /* FIXME: add test for this */
    for (;low + 1 < high;) {
        npy_intp       ll = low + 1;
        npy_intp       hh = high;

        /*
         * if we aren't making sufficient progress with median of 3
         * fall back to median-of-median5 pivot for linear worst case
         * med3 for small sizes is required to do unguarded partition
         */
        if (depth_limit > 0 || hh - ll < 5) {
            const npy_intp mid = low + (high - low) / 2;
            /* median of 3 pivot strategy,
             * swapping for efficient partition */
            MEDIAN3_SWAP(v, tosort, low, mid, high);
        }
        else {
            npy_intp mid;
#if @arg@
            mid = ll + amedian_of_median5_@suff@(v, tosort + ll, hh - ll);
#else
            mid = ll + median_of_median5_@suff@(v + ll, hh - ll);
#endif
            SWAP(SORTEE(mid), SORTEE(low));
            /* adapt for the larger partition than med3 pivot */
            ll--;
            hh++;
        }

        depth_limit--;

        /*
         * find place to put pivot (in low):
         * previous swapping removes need for bound checks
         * pivot 3-lowest [x x x] 3-highest
         */
        UNGUARDED_PARTITION(v, tosort, v[IDX(low)], &ll, &hh);

        /* move pivot into position */
        SWAP(SORTEE(low), SORTEE(hh))

        if (hh >= kth)
            high = hh - 1;
        if (hh <= kth)
            low = ll;
    }

    /* two elements */
    if (high == low + 1)
        if (@TYPE@_LT(v[IDX(high)], v[IDX(low)]))
            SWAP(SORTEE(high), SORTEE(low))

    return 0;
}


#undef IDX
#undef SWAP
#undef SORTEE
#undef MEDIAN3_SWAP
#undef MEDIAN5
#undef UNGUARDED_PARTITION
#undef INTROSELECT
/**end repeat1**/

/**end repeat**/


/*
 *****************************************************************************
 **                             STRING SORTS                                **
 *****************************************************************************
 */


/**begin repeat
 *
 * #TYPE = STRING, UNICODE#
 * #suff = string, unicode#
 * #type = npy_char, npy_ucs4#
 */

int
introselect_@suff@(@type@ *start, npy_intp num, PyArrayObject *arr)
{
    return quicksort_@suff@(start, num, arr);
}


int
aintroselect_@suff@(@type@ *v, npy_intp* tosort, npy_intp num, PyArrayObject *arr)
{
    return aquicksort_@suff@(v, tosort, num, arr);
}

/**end repeat**/


/*
 *****************************************************************************
 **                             GENERIC SORT                                **
 *****************************************************************************
 */


/*
 * This sort has almost the same signature as libc qsort and is intended to
 * supply an error return for compatibility with the other generic sort
 * kinds.
 */
int
npy_introselect(void *base, size_t num, size_t size, size_t kth, npy_comparator cmp)
{
    return npy_quicksort(base, num, size, cmp);
}
