/* -*- c -*- */

/*
 * 
 * The code is based on the quickselect from
 * Nicolas Devillard - 1998 public domain
 * http://ndevilla.free.fr/median/median/
 *
 * Quick select is usually the fastest, but the worst case scenario can
 * be quadratic complexcity.
 */


#define NPY_NO_DEPRECATED_API NPY_API_VERSION

#include "npy_sort.h"
#include "npysort_common.h"
#include <stdlib.h>

#define NOT_USED NPY_UNUSED(unused)


/*
 *****************************************************************************
 **                            NUMERIC SORTS                                **
 *****************************************************************************
 */


/**begin repeat
 *
 * #TYPE = BOOL, BYTE, UBYTE, SHORT, USHORT, INT, UINT, LONG, ULONG,
 *         LONGLONG, ULONGLONG, HALF, FLOAT, DOUBLE, LONGDOUBLE,
 *         CFLOAT, CDOUBLE, CLONGDOUBLE#
 * #suff = bool, byte, ubyte, short, ushort, int, uint, long, ulong,
 *         longlong, ulonglong, half, float, double, longdouble,
 *         cfloat, cdouble, clongdouble#
 * #type = npy_bool, npy_byte, npy_ubyte, npy_short, npy_ushort, npy_int,
 *         npy_uint, npy_long, npy_ulong, npy_longlong, npy_ulonglong,
 *         npy_ushort, npy_float, npy_double, npy_longdouble, npy_cfloat,
 *         npy_cdouble, npy_clongdouble#
 */


/*
 * quickselect using 3-median as pivot, worst case O(n^2)
 */
int
quickselect_@suff@(@type@ *v, npy_intp num, npy_intp kth,
                   void *NOT_USED)
{
    npy_intp low  = 0;
    npy_intp high = num - 1;

    for (;low + 1 < high;) {
        const npy_intp mid = low + (high - low) / 2;
        npy_intp       ll = low + 1;
        npy_intp       hh = high;

        /* median of 3 pivot strategy */
        if (@TYPE@_LT(v[high], v[mid]))
            @TYPE@_SWAP(v[high], v[mid]);
        if (@TYPE@_LT(v[high], v[low]))
            @TYPE@_SWAP(v[high], v[low]);
        /* move pivot to low */
        if (@TYPE@_LT(v[low], v[mid]))
            @TYPE@_SWAP(v[low], v[mid]);
        /* move 3-lowest element to low + 1 */
        @TYPE@_SWAP(v[mid], v[low + 1]);

        /*
         * find place to put pivot (in low):
         * pivot 3-lowest [x x x] 3-highest
         */
        const @type@ t = v[low];
        for (;;) {
            do ll++; while (@TYPE@_LT(v[ll], t));
            do hh--; while (@TYPE@_LT(t, v[hh]));

            if (hh < ll)
                break;

            @TYPE@_SWAP(v[ll], v[hh])
        }

        /* move pivot into position */
        @TYPE@_SWAP(v[low], v[hh])

        if (hh >= kth)
            high = hh - 1;
        if (hh <= kth)
            low = ll;
    }

    if (high == low + 1)
        if (@TYPE@_LT(v[high], v[low]))
            @TYPE@_SWAP(v[high], v[low]);

    return 0;
}


/* select index of median of five elements */
static npy_intp median5_@suff@(@type@ * v)
{
    /* could be optimized as we don't need to swap */
    if (@TYPE@_LT(v[1], v[0])) {
        @TYPE@_SWAP(v[1], v[0]);
    }
    if (@TYPE@_LT(v[4], v[3])) {
        @TYPE@_SWAP(v[4], v[3]);
    }
    if (@TYPE@_LT(v[3], v[0])) {
        @TYPE@_SWAP(v[3], v[0]);
    }
    if (@TYPE@_LT(v[4], v[1])) {
        @TYPE@_SWAP(v[4], v[1]);
    }
    if (@TYPE@_LT(v[2], v[1])) {
        @TYPE@_SWAP(v[2], v[1]);
    }
    if (@TYPE@_LT(v[3], v[2])) {
        @TYPE@_SWAP(v[3], v[2]);
    }
    if (@TYPE@_LT(v[2], v[1])) {
        return 1;
    }
    else {
        return 2;
    }
}


int
quickselect_mom_@suff@(@type@ *v, npy_intp num, npy_intp kth,
                       void *NOT_USED);
static npy_intp
median_of_median5_@suff@(@type@ *v, const npy_intp num)
{
    npy_intp i;
    npy_intp right = num - 1;
    npy_intp nmed = (right + 1) / 5;
    npy_intp subleft = 0;
    for (i = 0; i < nmed; i++) {
        npy_intp m = median5_@suff@(v + subleft);
        @TYPE@_SWAP(v[subleft + m], v[i]);
        subleft += 5;
    }

    if (nmed > 2)
        quickselect_mom_@suff@(v, nmed, nmed / 2, NULL);
    return nmed / 2;
}


/*
 * quickselect using median of 5-median as pivot, worst case O(n)
 */
int
quickselect_mom_@suff@(@type@ *v, npy_intp num, npy_intp kth,
                       void *NOT_USED)
{
    npy_intp low  = 0;
    npy_intp high = num - 1;

    for (;low + 1 < high;) {
        npy_intp       ll = low;
        npy_intp       hh = high + 1;
        const npy_intp mid = ll + median_of_median5_@suff@(v + ll, hh - ll);

        @TYPE@_SWAP(v[mid], v[low]);

        /*
         * find place to put pivot (in low):
         * pivot [x x x]
         */
        const @type@ t = v[low];
        for (;;) {
            do ll++; while (ll < num && @TYPE@_LT(v[ll], t));
            do hh--; while (@TYPE@_LT(t, v[hh]));

            if (hh < ll)
                break;

            @TYPE@_SWAP(v[ll], v[hh])
        }

        /* move pivot into position */
        @TYPE@_SWAP(v[low], v[hh])

        if (hh >= kth)
            high = hh - 1;
        if (hh <= kth)
            low = ll;
    }

    if (high == low + 1)
        if (@TYPE@_LT(v[high], v[low]))
            @TYPE@_SWAP(v[high], v[low]);

    return 0;
}


int
aquickselect_@suff@(@type@ *v, npy_intp* tosort, npy_intp num, npy_intp kth, void *NOT_USED)
{
    npy_intp low  = 0;
    npy_intp high = num - 1;

    for (;low + 1 < high;) {
        const npy_intp mid = low + (high - low) / 2;
        npy_intp       ll = low + 1;
        npy_intp       hh = high;

        /* median of 3 pivot strategy */
        if (@TYPE@_LT(v[tosort[high]], v[tosort[mid]]))
            INTP_SWAP(tosort[high], tosort[mid]);
        if (@TYPE@_LT(v[tosort[high]], v[tosort[low]]))
            INTP_SWAP(tosort[high], tosort[low]);
        /* move pivot to low */
        if (@TYPE@_LT(v[tosort[low]], v[tosort[mid]]))
            INTP_SWAP(tosort[low], tosort[mid]);
        /* move 3-lowest element to low + 1 */
        INTP_SWAP(tosort[mid], tosort[low + 1]);

        /*
         * find place to put pivot (in low):
         * pivot 3-lowest [x x x] 3-highest
         */
        const @type@ t = v[tosort[low]];
        for (;;) {
            do ll++; while (ll < num && @TYPE@_LT(v[tosort[ll]], t));
            do hh--; while (@TYPE@_LT(t, v[tosort[hh]]));

            if (hh < ll)
                break;

            INTP_SWAP(tosort[ll], tosort[hh])
        }

        /* move pivot into position */
        INTP_SWAP(tosort[low], tosort[hh])

        if (hh >= kth)
            high = hh - 1;
        if (hh <= kth)
            low = ll;
    }

    if (high == low + 1)
        if (@TYPE@_LT(v[tosort[high]], v[tosort[low]]))
            INTP_SWAP(tosort[high], tosort[low]);

    return 0;
}


/* select index of median of five elements */
static npy_intp amedian5_@suff@(const @type@ * v, npy_intp * tosort)
{
    /* could be optimized as we don't need to swap */
    if (@TYPE@_LT(v[tosort[1]], v[tosort[0]])) {
        INTP_SWAP(tosort[1], tosort[0]);
    }
    if (@TYPE@_LT(v[tosort[4]], v[tosort[3]])) {
        INTP_SWAP(tosort[4], tosort[3]);
    }
    if (@TYPE@_LT(v[tosort[3]], v[tosort[0]])) {
        INTP_SWAP(tosort[3], tosort[0]);
    }
    if (@TYPE@_LT(v[tosort[4]], v[tosort[1]])) {
        INTP_SWAP(tosort[4], tosort[1]);
    }
    if (@TYPE@_LT(v[tosort[2]], v[tosort[1]])) {
        INTP_SWAP(tosort[2], tosort[1]);
    }
    if (@TYPE@_LT(v[tosort[3]], v[tosort[2]])) {
        INTP_SWAP(tosort[3], tosort[2]);
    }
    if (@TYPE@_LT(v[tosort[2]], v[tosort[1]])) {
        return 1;
    }
    else {
        return 2;
    }
}

int
aquickselect_mom_@suff@(@type@ *v, npy_intp* tosort, npy_intp num,
                        npy_intp kth, void *NOT_USED);

static npy_intp
amedian_of_median5_@suff@(@type@ *v, npy_intp* tosort, const npy_intp num)
{
    npy_intp i;
    npy_intp right = num - 1;
    npy_intp nmed = (right + 1) / 5;
    npy_intp subleft = 0;
    for (i = 0; i < nmed; i++) {
        npy_intp m = amedian5_@suff@(v, tosort + subleft);
        INTP_SWAP(tosort[subleft + m], tosort[i]);
        subleft += 5;
    }

    if (nmed > 2)
        aquickselect_mom_@suff@(v, tosort, nmed, nmed / 2, NULL);
    return nmed / 2;
}


/*
 * quickselect using median of 5-median as pivot, worst case O(n)
 */
int
aquickselect_mom_@suff@(@type@ *v, npy_intp* tosort, npy_intp num,
                        npy_intp kth, void *NOT_USED)
{
    npy_intp low  = 0;
    npy_intp high = num - 1;

    for (;low + 1 < high;) {
        npy_intp       ll = low;
        npy_intp       hh = high + 1;
        const npy_intp mid = ll + amedian_of_median5_@suff@(v,
                                                            tosort + ll,
                                                            hh - ll);

        INTP_SWAP(tosort[mid], tosort[low]);

        /*
         * find place to put pivot (in low):
         * pivot [x x x]
         */
        const @type@ t = v[tosort[low]];
        for (;;) {
            do ll++; while (ll < num && @TYPE@_LT(v[tosort[ll]], t));
            do hh--; while (@TYPE@_LT(t, v[tosort[hh]]));

            if (hh < ll)
                break;

            INTP_SWAP(tosort[ll], tosort[hh])
        }

        /* move pivot into position */
        INTP_SWAP(tosort[low], tosort[hh])

        if (hh >= kth)
            high = hh - 1;
        if (hh <= kth)
            low = ll;
    }

    if (high == low + 1)
        if (@TYPE@_LT(v[tosort[high]], v[tosort[low]]))
            INTP_SWAP(tosort[high], tosort[low]);

    return 0;
}

/**end repeat**/


/*
 *****************************************************************************
 **                             STRING SORTS                                **
 *****************************************************************************
 */


/**begin repeat
 *
 * #TYPE = STRING, UNICODE#
 * #suff = string, unicode#
 * #type = npy_char, npy_ucs4#
 */

int
quickselect_@suff@(@type@ *start, npy_intp num, PyArrayObject *arr)
{
    return quicksort_@suff@(start, num, arr);
}


int
aquickselect_@suff@(@type@ *v, npy_intp* tosort, npy_intp num, PyArrayObject *arr)
{
    return aquicksort_@suff@(v, tosort, num, arr);
}

/**end repeat**/


/*
 *****************************************************************************
 **                             GENERIC SORT                                **
 *****************************************************************************
 */


/*
 * This sort has almost the same signature as libc qsort and is intended to
 * supply an error return for compatibility with the other generic sort
 * kinds.
 */
int
npy_quickselect(void *base, size_t num, size_t size, npy_comparator cmp)
{
    return npy_quicksort(base, num, size, cmp);
}
