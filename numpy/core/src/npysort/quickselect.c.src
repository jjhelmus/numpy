/* -*- c -*- */

/*
 * 
 * The code is based on the quickselect from
 * Nicolas Devillard - 1998 public domain
 * http://ndevilla.free.fr/median/median/
 *
 * Quick select is usually the fastest, but the worst case scenario can
 * be quadratic complexcity.
 */


#define NPY_NO_DEPRECATED_API NPY_API_VERSION

#include <stdlib.h>
#include "npy_sort.h"
#include "npysort_common.h"

#define NOT_USED NPY_UNUSED(unused)


/*
 *****************************************************************************
 **                            NUMERIC SORTS                                **
 *****************************************************************************
 */


/**begin repeat
 *
 * #TYPE = BOOL, BYTE, UBYTE, SHORT, USHORT, INT, UINT, LONG, ULONG,
 *         LONGLONG, ULONGLONG, HALF, FLOAT, DOUBLE, LONGDOUBLE,
 *         CFLOAT, CDOUBLE, CLONGDOUBLE#
 * #suff = bool, byte, ubyte, short, ushort, int, uint, long, ulong,
 *         longlong, ulonglong, half, float, double, longdouble,
 *         cfloat, cdouble, clongdouble#
 * #type = npy_bool, npy_byte, npy_ubyte, npy_short, npy_ushort, npy_int,
 *         npy_uint, npy_long, npy_ulong, npy_longlong, npy_ulonglong,
 *         npy_ushort, npy_float, npy_double, npy_longdouble, npy_cfloat,
 *         npy_cdouble, npy_clongdouble#
 */

int
quickselect_@suff@(@type@ *v, npy_intp num, npy_intp kth,
                   void *NOT_USED)
{
    npy_intp low  = 0;
    npy_intp high = num - 1;

    for (;low + 1 < high;) {
        const npy_intp mid = low + (high - low) / 2;
        npy_intp       ll = low + 1;
        npy_intp       hh = high;

        /* median of 3 pivot strategy */
        if (@TYPE@_LT(v[high], v[mid]))
            @TYPE@_SWAP(v[high], v[mid]);
        if (@TYPE@_LT(v[high], v[low]))
            @TYPE@_SWAP(v[high], v[low]);
        /* move pivot to low */
        if (@TYPE@_LT(v[low], v[mid]))
            @TYPE@_SWAP(v[low], v[mid]);
        /* move 3-lowest element to low + 1 */
        @TYPE@_SWAP(v[mid], v[low + 1]);

        /*
         * find place to put pivot (in low):
         * pivot 3-lowest [x x x] 3-highest
         */
        const @type@ t = v[low];
        for (;;) {
            do ll++; while (@TYPE@_LT(v[ll], t));
            do hh--; while (@TYPE@_LT(t, v[hh]));

            if (hh < ll)
                break;

            @TYPE@_SWAP(v[ll], v[hh])
        }

        /* move pivot into position */
        @TYPE@_SWAP(v[low], v[hh])

        if (hh >= kth)
            high = hh - 1; 
        if (hh <= kth)
            low = ll;
    }

    if (high == low + 1)
        if (@TYPE@_LT(v[high], v[low]))
            @TYPE@_SWAP(v[high], v[low]);

    return 0;
}


int
aquickselect_@suff@(@type@ *v, npy_intp* tosort, npy_intp num, npy_intp kth, void *NOT_USED)
{
    npy_intp low  = 0;
    npy_intp high = num - 1;

    for (;low + 1 < high;) {
        const npy_intp mid = low + (high - low) / 2;
        npy_intp       ll = low + 1;
        npy_intp       hh = high;

        /* median of 3 pivot strategy */
        if (@TYPE@_LT(v[tosort[high]], v[tosort[mid]]))
            INTP_SWAP(tosort[high], tosort[mid]);
        if (@TYPE@_LT(v[tosort[high]], v[tosort[low]]))
            INTP_SWAP(tosort[high], tosort[low]);
        /* move pivot to low */
        if (@TYPE@_LT(v[tosort[low]], v[tosort[mid]]))
            INTP_SWAP(tosort[low], tosort[mid]);
        /* move 3-lowest element to low + 1 */
        INTP_SWAP(tosort[mid], tosort[low + 1]);

        /*
         * find place to put pivot (in low):
         * pivot 3-lowest [x x x] 3-highest
         */
        const @type@ t = v[tosort[low]];
        for (;;) {
            do ll++; while (@TYPE@_LT(v[tosort[ll]], t));
            do hh--; while (@TYPE@_LT(t, v[tosort[hh]]));

            if (hh < ll)
                break;

            INTP_SWAP(tosort[ll], tosort[hh])
        }

        /* move pivot into position */
        INTP_SWAP(tosort[low], tosort[hh])

        if (hh >= kth)
            high = hh - 1; 
        if (hh <= kth)
            low = ll;
    }

    if (high == low + 1)
        if (@TYPE@_LT(v[tosort[high]], v[tosort[low]]))
            INTP_SWAP(tosort[high], tosort[low]);

    return 0;
}

/**end repeat**/


/*
 *****************************************************************************
 **                             STRING SORTS                                **
 *****************************************************************************
 */


/**begin repeat
 *
 * #TYPE = STRING, UNICODE#
 * #suff = string, unicode#
 * #type = npy_char, npy_ucs4#
 */

int
quickselect_@suff@(@type@ *start, npy_intp num, PyArrayObject *arr)
{
    return quicksort_@suff@(start, num, arr);
}


int
aquickselect_@suff@(@type@ *v, npy_intp* tosort, npy_intp num, PyArrayObject *arr)
{
    return aquicksort_@suff@(v, tosort, num, arr);
}

/**end repeat**/


/*
 *****************************************************************************
 **                             GENERIC SORT                                **
 *****************************************************************************
 */


/*
 * This sort has almost the same signature as libc qsort and is intended to
 * supply an error return for compatibility with the other generic sort
 * kinds.
 */
int
npy_quickselect(void *base, size_t num, size_t size, npy_comparator cmp)
{
    return npy_quicksort(base, num, size, cmp);
}
